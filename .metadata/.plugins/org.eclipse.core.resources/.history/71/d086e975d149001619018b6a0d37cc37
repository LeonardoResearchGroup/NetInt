package utilities;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;

import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.Direction;
//import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.impls.tg.TinkerGraph;
import com.tinkerpop.blueprints.util.io.graphml.GraphMLReader;

import edu.uci.ics.jung.graph.DirectedSparseMultigraph;
import edu.uci.ics.jung.graph.util.EdgeType;
import graphElements.Node;
import graphElements.Edge;

public class GraphmlReader {

	private Graph graph;
	ArrayList<String> communities;
	
	public GraphmlReader(String xmlFile) {
		graph = new TinkerGraph();
		GraphMLReader reader = new GraphMLReader(graph);
		communities = new ArrayList<String>();

		InputStream input;
		try {
			input = new BufferedInputStream(new FileInputStream(xmlFile));
			reader.inputGraph(input);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public DirectedSparseMultigraph<Node, Edge> getJungDirectedGraph(String communityKey) {
		DirectedSparseMultigraph<Node, Edge> rtnGraph = new DirectedSparseMultigraph<Node, Edge>();

		for (com.tinkerpop.blueprints.Edge edge : graph.getEdges()) {
			// From each edge retrieve the source and target vertex
			Vertex source = edge.getVertex(Direction.IN);
			Vertex target = edge.getVertex(Direction.OUT);
			// Get their ID
			int idSource = Integer.parseInt(source.getId().toString().replace("n", ""));
			int idTarget = Integer.parseInt(target.getId().toString().replace("n", ""));
			// Instantiate Nodes
			Node sourceNode = new Node(idSource);
			Node targetNode = new Node(idTarget);
			
			//Check if exist a property named "comunidad"
			if(source.getProperty(communityKey) != null && target.getProperty(communityKey) != null){
				// Get and store communities 
				sourceNode.setCommunity((String)source.getProperty(communityKey),1);
//				int sourceCommunitie = (int) Double.parseDouble(source.getProperty(communityKey).toString());
//				int targetCommunitie = (int) Double.parseDouble(target.getProperty(communityKey).toString());
				addCommunitie(sourceNode.getCommunity(1));
				addCommunitie(sourceCommunitie);
				
				// Classify in communities
				sourceNode.includeInSubGraph(sourceCommunitie);
				targetNode.includeInSubGraph(targetCommunitie);
			}
			
			// Add Attributes
//			sourceNode.setName((String) source.getProperty("label"));
//			sourceNode.setCommunity("World");
//			sourceNode.setCommunity((String)source.getProperty("Continent"),1);
//
//			targetNode.setName((String) target.getProperty("label"));
//			targetNode.setCommunity("World");
//			targetNode.setCommunity((String)target.getProperty("Continent"),1);


			// Add graphElements to collection
			graphElements.Edge e = new graphElements.Edge(sourceNode, targetNode, true);
			String val = String.valueOf((Double) edge.getProperty("weight"));
			e.setWeight(Float.valueOf(val));
			rtnGraph.addEdge(e, sourceNode, targetNode, EdgeType.DIRECTED);
		}	
		return rtnGraph;
	}
	
	public TinkerGraph getTinkerGraph() {
		TinkerGraph rtnGraph = new TinkerGraph();

		for (com.tinkerpop.blueprints.Edge edge : graph.getEdges()) {
			// From each edge retrieve the source and target vertex
			Vertex source = edge.getVertex(Direction.IN);
			Vertex target = edge.getVertex(Direction.OUT);
			// Get their ID
			int idSource = Integer.parseInt(source.getId().toString().replace("n", ""));
			int idTarget = Integer.parseInt(target.getId().toString().replace("n", ""));
			// Instantiate Nodes
			Node sourceNode = new Node(idSource);
			Node targetNode = new Node(idTarget);
			// Add Attributes
			sourceNode.setName((String) source.getProperty("label"));
			sourceNode.setCommunity((String)source.getProperty("Continent"));
			targetNode.setName((String) target.getProperty("label"));
			targetNode.setCommunity((String)target.getProperty("Continent"));

			// Add graphElements to collection
			graphElements.Edge e = new graphElements.Edge(sourceNode, targetNode, true);
			String val = String.valueOf((Double) edge.getProperty("weight"));
			e.setWeight(Float.valueOf(val));
			rtnGraph.addEdge(e, source, target, "directed");
		}
		return rtnGraph;
	}
	
	public graphElements.Graph getGraphJuan(String communityKey) {
		graphElements.Graph rtn = new graphElements.Graph();
		ArrayList<graphElements.Edge> edges = new ArrayList<graphElements.Edge>();
		ArrayList<Node> nodes = new ArrayList<Node>();

		for (com.tinkerpop.blueprints.Edge edge : graph.getEdges()) {
			// From each edge retrieve the source and target vertex
			Vertex source = edge.getVertex(Direction.IN);
			Vertex target = edge.getVertex(Direction.OUT);
			
			Set <String> h = source.getPropertyKeys();
			System.out.println(h);
			
			// Get their ID
			// Instantiate Nodes
			Node sourceNode = new Node(source.getId().toString());
			Node targetNode = new Node(target.getId().toString());
			
			//Check if exist a property named "comunidad"
			if(source.getProperty(communityKey) != null && target.getProperty(communityKey) != null){
				// Get and store communities 
				int sourceCommunitie = (int) Double.parseDouble(source.getProperty(communityKey).toString());
				int targetCommunitie = (int) Double.parseDouble(target.getProperty(communityKey).toString());
				addCommunitie(sourceCommunitie);
				addCommunitie(sourceCommunitie);
				
				// Classify in communities
				sourceNode.includeInSubGraph(sourceCommunitie);
				targetNode.includeInSubGraph(targetCommunitie);
			}
			
			// add nodes to collection.
			int index = nodes.indexOf(sourceNode);
			// If sourceNode not in the list yet
			if (index == -1) {
				// Add to the list
				nodes.add(sourceNode);
			} else {
				// Get from the list
				sourceNode = nodes.get(index);
			}
			// If targetNode not in the list yet
			index = nodes.indexOf(targetNode);
			if (index == -1) {
				nodes.add(targetNode);
			} else {
	
				targetNode = nodes.get(index);
			}
			// Generate graphElements.Edge
			graphElements.Edge e = new graphElements.Edge(sourceNode, targetNode, true);
			// Add graphElements.Edge to collection
			edges.add(e);
		}

		// This needs a better solution. The ideal solution is to rework the
		// entire code replacing the nodes ArrayList for a TreeSet. It might be
		// simple instead when it is needed to retrieve a particular instance
		// from the set.
		// That is the case of some methods in Container and RandomGraphFactory
		ArrayList<Node> listNodes = new ArrayList<Node>(nodes);
		rtn = new graphElements.Graph(listNodes, edges);
		return rtn;

	}
	
	public ArrayList<String> getCommunities(){
		return communities;
	}
	
	private void addCommunitie(String string){
		// If community not in the list yet
		int index = communities.contains(string);
		if (index == -1) {
			communities.add(string);
		} 
	}
	
	public Set<String> getKeys(){
		return graph.getVertices().iterator().next().getPropertyKeys();
	}

}